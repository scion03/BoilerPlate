#1 greedy
#2 binary search
#3 interchanging/deleting/inserting while traversing(greedy 2.0)
#4 Brute Force(with huge caution)!
#5 Maintaining multisets/PQs
#6 Stacks and Queues the O(m+n) approach!! //whenever in need of NGE
#7 Make a graph and use DFS/Bipartite?
#8 Segment Trees/Sparse Table
#9 pre-computation
#10 Brute Force in n*root(n)
#11 Hit and Trial, n and 1 in first Q!!
for predf(yes or no) questions, you can also try predicting the answer using range and difference etc rather than focusing solely on getting the exact answer as it may be np haard some times!
#12 2 pointers from 0,0!
#13 always think the two pointers from both the ends(j-i==0 or j-i==n)!
#14 perm-DSU
#15 Storing prev queries and then using them to answer the latest ones!
#16 Always think from both the ends: ( for ex Fi<=Fi+1 as well as Fi>=Fi-1)
// Always use the 100% sure approaches!
// Always be optimistic: solution always exists!!!!
#17 Sometimes, you have to you use such a greedy approach, which has minimum thought and maximum optimality(Question itself does the work!)!
to compare a set of vectors, convert them into whole strings and then compare!!
#18 all the pairs of numbers less than n, such that x.y<n can be traversed over in nlogn!!!!!!
#19 nrootn algos
#20 number of partitions as n/1+n/2+n/3==nlogn*logn(to calculate for each partiton)!
#21 first solve in O(n) for i<=rootn then solve in rootn for remaing O(n) -> when there're approx n/i*O(n) comps req.
#22 contribution to the sum technique, rather than queries focus on a point value's contribution to queries.
#23 Using bitset to mark visited